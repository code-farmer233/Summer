二分图指的是这样一种图，其所有顶点可以分成两个集合X和Y，其中X或Y中任意两个在同一集合中的点都不相连，所有的边关联在两个顶点中，恰好一个属于集合Ｘ，另一个属于集合Ｙ。
给定一个二分图G，M为G边集的一个子集，如果M满足当中的任意两条边都不依附于同一个顶点，则称M是一个匹配。图中包含边数最多的匹配称为图的最大匹配。
二分图的最大匹配中的匈牙利算法，它的基本模式就是：
 初始时最大匹配为空
  while 找得到增广路径
    do 把增广路径加入到最大匹配中去
算法的思路是不停的找增广路径, 并增加匹配的个数,增广路径顾名思义是指一条可以使匹配数变多的路径，在匹配问题中,增广路径的表现形式是一条"交错路径"，也就是说这条由图的边组成的路径，
它的第一条边是目前还没有参与匹配的，第二条边参与了匹配，第三条边没有..最后一条边没有参与匹配，并且始点和终点还没有被选择过。这样交错进行，显然他有奇数条边。那么对于这样一条路径，
我们可以将第一条边改为已匹配，第二条边改为未匹配...以此类推。也就是将所有的边进行"反色"，容易发现这样修改以后，匹配仍然是合法的，但是匹配数增加了一对。
另外，单独的一条连接两个未匹配点的边显然也是交错路径。可以证明。当不能再找到增广路径时，就得到了一个最大匹配，这也就是匈牙利算法的思路。

3个重要结论：
最小点覆盖数： 最小覆盖要求用最少的点（Ｘ集合或Ｙ集合的都行）让每条边都至少和其中一个点关联。可以证明：最少的点（即覆盖数）＝最大匹配数
最小路径覆盖=最小路径覆盖＝｜N｜－最大匹配数
用尽量少的不相交简单路径覆盖有向无环图Ｇ的所有结点。解决此类问题可以建立一个二分图模型。把所有顶点i拆成两个：Ｘ结点集中的i和Y结点集中的i'，如果有边i->j，则在二分图中引入边i->j'，设二分图最大匹配为m，则结果就是n-m。
二分图最大独立集=顶点数-二分图最大匹配
在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边，求m最大值。
如果图Ｇ满足二分图条件，则可以用二分图匹配来做．最大独立集点数 = N - 最大匹配数。

题意：给出一个矩形N*M棋盘，有K个格子是空洞，然后用2*1的矩形，对所有非空洞的格子进行覆盖，如果可以全部覆盖，就puts("YES");
算法：建立二分图，用匈牙利算法；
我们分别对所有的格子进行标号1.。。N*M
将问题转化为二分图最大匹配问题。将棋盘按国际象棋棋盘那样添上黑白两种颜色，这样的话，黑色和白色的格子就构成了二分图的两个集合，即相邻的两个格子不会属于同个集合的。
然后从上到下，从左到右对格子进行编号（除了洞）,相邻的两格用边相连就构成一个二分图。然后求出最大匹配。。如果最大匹配+K=N*M就输出YES。
二分图建图就是对于每一个不是洞的点，往4个方向扩展，如果哪个方向有不是洞的点，那么就可以连上一条边，然后我们再求这个二分图的最大匹配，然后判断它是否是一个完备匹配（即所有点都在匹配边上的匹配）
二分图永远是单向的，本题中的二分图中的x和y是一样的，但是即使这样也不能认为这个二分图是双向的，在本题通过上面的方法建图以后，我们只要求出最大独立集的个数是不是等于洞的个数，或者判断这个二分图是不是完备的就行了。
代码：
#include<stdio.h>
#include<memory.h>
#define MAX 1089 
bool g[MAX][MAX]; 
bool flag,visit[MAX];   
int match[MAX];   
int cnt;   
bool hole[MAX][MAX];
int id[MAX][MAX];
bool dfs(int u)
{
	for (int i = 1; i <= cnt; ++i)
	{
		if (g[u][i] && !visit[i])  
		{
			visit[i] = true;  
			if (match[i] == -1 || dfs(match[i]))   
			{
				match[i] = u; 
				return true; 
			}
		}
	}
	return false;
}
int MaxMatch()
{
	int i,sum=0;
	memset(match,-1,sizeof(match));
	for(i = 1 ; i <= cnt ; ++i)
	{
		memset(visit,false,sizeof(visit));  
		if( dfs(i) )  
		{
			sum++;
		}
	}
	return sum;
}
 
int main(void)
{
    int i,j,k,m,n,ans,y,x;
    while (scanf("%d %d %d",&m,&n,&k)!=EOF)
    {
		  memset(g,false,sizeof(g));
		  memset(hole,false,sizeof(hole));
          for (i = 1; i <= k; ++i)
		  {
			  scanf("%d %d",&y,&x);
              hole[x][y] = true;
		  }
		  if((m*n-k)&1)  
		  {
			  puts("NO");
			  continue;
		  }
          cnt = 0;
 
          for (i = 1; i <= m; ++i)
          {
			  for (j = 1; j <= n; ++j)
			  {
				  if(hole[i][j] == false)  
				  {
					  id[i][j] = ++cnt;
				  }
			  }
          }
		  for (i = 1; i <= m; ++i)
          {
			  for (j = 1; j <= n; ++j)
			  {
				  if(hole[i][j] == false)
				  {
					  if(i-1>0 && hole[i-1][j] == false)   
						  g[ id[i][j] ][ id[i-1][j] ] = true;
					  if(i+1<=m && hole[i+1][j] == false)
						  g[ id[i][j] ][ id[i+1][j] ] = true;
					  if(j-1>0 && hole[i][j-1] == false)
						  g[ id[i][j] ][ id[i][j-1] ] = true;
					  if(j+1<=n && hole[i][j+1] == false)
						  g[ id[i][j] ][ id[i][j+1] ] = true;
				  }
			  }
		  }
 
		  ans = MaxMatch();
		  if (ans == cnt)
			  puts("YES");
		  else
			  puts("NO");
	}
    
    return 0;
}
