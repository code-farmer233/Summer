统计数字字符个数
总时间限制: 1000ms 内存限制: 65536kB
描述
输入一行字符，统计出其中数字字符的个数。
输入
一行字符串，总长度不超过255。
输出
输出为1行，输出字符串里面数字字符的个数。
样例输入
Peking University is set up at 1898.
样例输出
4
ac代码：
#include<stdio.h>
#include<string.h> 
int main()
{
	char s[255];
	int count=0,n;
	gets(s); 
	n=strlen(s);
	for(int i=0;i<n;i++)
	if(s[i]-'0'>=0&&s[i]-'0'<=9)
	count++;
	printf("%d",count);
	return 0;
}



找第一个只出现一次的字符
总时间限制: 1000ms 内存限制: 65536kB
描述
给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出no。
输入
一个字符串，长度小于100000。
输出
输出第一个仅出现一次的字符，若没有则输出no。
样例输入
abcabd
样例输出
c
ac代码：
#include<iostream>
#include<cstring> 
using namespace std;
int a[128]={0};
char b[100010];
int main()
{
	int flag=0;     
	gets(b);
	int s=strlen(b);
	for(int i=0;i<s;i++)
		a[b[i]]++;
	for(int i=0;i<s;i++)
	{
		int t=(int)b[i];
		if(a[t]==1)
		{
			flag=1;
			cout<<b[i]<<endl;
			break; 
		}
	}
	if(flag==0)
		cout<<"no"<<endl;
	return 0;
}
解题思路：这道题如果用笨法子一个一个去比的话，肯定会超时，所以要想一个更简单的算法。这时候就要想到ASCII码，
ASCII码的总共就128个，所以用一个128的数组存放当前下标值大小的字符的出现次数，这样就比较容易实现了。



笨小猴
题目描述
笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！
这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。
输入格式
一个单词，其中只可能出现小写字母，并且长度小于100100。
输出格式
共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；
第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出00。
输入输出样例
输入 
error
输出 
Lucky Word
2
输入 
olympic
输出 
No Answer
0
ac代码：
#include <bits/stdc++.h>
using namespace std;
char s[110];
const int prime[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};//打表
int sum[26];//记录和
int main(){
	int maxn=0,minn=110;
	scanf("%s",s);
	int len=strlen(s);
	for(int i=0;i<len;i++){//遍历字符串
		sum[s[i]-'a']++;
	}
	for(int i=0;i<26;i++){//遍历26个字母
		if(sum[i]>maxn) maxn=sum[i];//比较maxn
		if(sum[i]>0&&sum[i]<minn) minn=sum[i];//比较minn，只比较出现过的字母
	}
	for(int i=0;i<25;i++){//遍历25个质数
		if(maxn-minn==prime[i]){
			printf("Lucky Word\n%d",maxn-minn);
			return 0;
		}
	}
	printf("No Answer\n0");
	return 0;
}
