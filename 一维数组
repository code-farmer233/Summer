陶陶摘苹果
总时间限制: 1000ms 内存限制: 65536kB
描述
陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。
现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。
输入
包括两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。
输出
包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。
样例输入
100 200 150 140 129 134 167 198 200 111
110
样例输出
5
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int i,a[10],m,sum=0;
	for(i=0;i<10;i++)
	scanf("%d",&a[i]);
	scanf("%d",&m);
	for(i=0;i<10;i++)
	 if(a[i]<=m+30)
	   sum++;
	 printf("%d",sum);
	return 0;
}
先定义一个数组，然后再把数据输进去，最后再将数组里的数据一个一个和陶陶所能达到的最大高度进行比较，最后输出结果。需要注意的是，这里由于输入数据的先后，导致必须用两个循环来分别进行输入和比较，
如果先输入最大高度再输入10个苹果到地面的高度，则一个循环即可。



计算书费
总时间限制: 1000ms 内存限制: 65536kB
描述
下面是一个图书的单价表：
计算概论 28.9 元/本
数据结构与算法 32.7 元/本
数字逻辑 45.6元/本
C++程序设计教程 78 元/本
人工智能 35 元/本
计算机体系结构 86.2 元/本
编译原理 27.8元/本
操作系统 43 元/本
计算机网络 56 元/本
JAVA程序设计 65 元/本
给定每种图书购买的数量，编程计算应付的总费用。

输入
输入一行，包含10个整数(大于等于0，小于等于100)，分别表示购买的《计算概论》、《数据结构与算法》、《数字逻辑》、《C++程序设计教程》、《人工智能》、《计算机体系结构》、《编译原理》、《操作系统》、《计算机网络》、《JAVA程序设计》的数量（以本为单位）。每两个整数用一个空格分开。
输出
输出一行，包含一个浮点数f，表示应付的总费用。精确到小数点后一位。
样例输入
1 5 8 10 5 1 1 2 3 4
样例输出
2140.2
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int i,a[10];
	float sum=0;
	for(i=0;i<10;i++){
	scanf("%d",&a[i]);
	switch(i){
		case 0:sum+=a[0]*28.9;break;
		case 1:sum+=a[1]*32.7;break;
		case 2:sum+=a[2]*45.6;break;
		case 3:sum+=a[3]*78;break;
		case 4:sum+=a[4]*35;break;
		case 5:sum+=a[5]*86.2;break;
		case 6:sum+=a[6]*27.8;break;
		case 7:sum+=a[7]*43;break;
		case 8:sum+=a[8]*56;break;
		case 9:sum+=a[9]*65;break;
	   } 
    }    
	printf("%.1f",sum);
	return 0;
与上题一样，先定义一个数组，然后再把数据输进去，不同的数据要乘以不同的单价，选用switch语句将各种书总价算出并加和，得总费用



校门外的树
总时间限制: 1000ms 内存限制: 65536kB
描述
某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。
由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
输入
第一行有两个整数L（1 <= L <= 10000）和 M（1 <= M <= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
对于20%的数据，区域之间没有重合的部分；
对于其它的数据，区域之间有重合的情况。
输出
包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。
样例输入
500 3
150 300
100 200
470 471
样例输出
298
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int l,m,n,a[10000],sum=0,i,x,y;
	scanf("%d%d",&l,&m);
	for(i=0;i<=l;i++)
	a[i]=1;
	n=l+1;
	for(i=1;i<=m;i++){
	  scanf("%d%d",&x,&y);
      for(int s=x;s<=y;s++)
      if(a[s]){
    	a[s]=0;
    	n--;}
	}
	printf("%d",n);
	return 0;
}
这道题要用到标记法，将数轴上的所有树都标记为1，在区域中间的树由1标记为0，同时将总数减1。所有区域标完后，即可得最后的剩余的树的数目。



数组逆序重放
总时间限制: 1000ms 内存限制: 65536kB
描述
将一个数组中的值按逆序重新存放。例如，原来的顺序为8,6,5,4,1。要求改为1,4,5,6,8。
输入
输入为两行：第一行数组中元素的个数n（1<n<100)，第二行是n个整数，每两个整数之间用空格分隔。
输出
输出为一行：输出逆序后数组的整数，每两个整数之间用空格分隔。
样例输入
5
8 6 5 4 1
样例输出
1 4 5 6 8
ac代码：
#include<stdio.h>
int main()
{
	int i,a[100],n;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	for(i=n-1;i>=0;i--)
	printf("%d ",a[i]);
	return 0;
}
这个题其实可以讨巧，不需要将数组中的值按逆序重新存放，只需要逆序输出就可以了。
