陶陶摘苹果
总时间限制: 1000ms 内存限制: 65536kB
描述
陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。
现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。
输入
包括两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。
输出
包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。
样例输入
100 200 150 140 129 134 167 198 200 111
110
样例输出
5
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int i,a[10],m,sum=0;
	for(i=0;i<10;i++)
	scanf("%d",&a[i]);
	scanf("%d",&m);
	for(i=0;i<10;i++)
	 if(a[i]<=m+30)
	   sum++;
	 printf("%d",sum);
	return 0;
}
先定义一个数组，然后再把数据输进去，最后再将数组里的数据一个一个和陶陶所能达到的最大高度进行比较，最后输出结果。需要注意的是，这里由于输入数据的先后，导致必须用两个循环来分别进行输入和比较，
如果先输入最大高度再输入10个苹果到地面的高度，则一个循环即可。



计算书费
总时间限制: 1000ms 内存限制: 65536kB
描述
下面是一个图书的单价表：
计算概论 28.9 元/本
数据结构与算法 32.7 元/本
数字逻辑 45.6元/本
C++程序设计教程 78 元/本
人工智能 35 元/本
计算机体系结构 86.2 元/本
编译原理 27.8元/本
操作系统 43 元/本
计算机网络 56 元/本
JAVA程序设计 65 元/本
给定每种图书购买的数量，编程计算应付的总费用。

输入
输入一行，包含10个整数(大于等于0，小于等于100)，分别表示购买的《计算概论》、《数据结构与算法》、《数字逻辑》、《C++程序设计教程》、《人工智能》、《计算机体系结构》、《编译原理》、《操作系统》、《计算机网络》、《JAVA程序设计》的数量（以本为单位）。每两个整数用一个空格分开。
输出
输出一行，包含一个浮点数f，表示应付的总费用。精确到小数点后一位。
样例输入
1 5 8 10 5 1 1 2 3 4
样例输出
2140.2
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int i,a[10];
	float sum=0;
	for(i=0;i<10;i++){
	scanf("%d",&a[i]);
	switch(i){
		case 0:sum+=a[0]*28.9;break;
		case 1:sum+=a[1]*32.7;break;
		case 2:sum+=a[2]*45.6;break;
		case 3:sum+=a[3]*78;break;
		case 4:sum+=a[4]*35;break;
		case 5:sum+=a[5]*86.2;break;
		case 6:sum+=a[6]*27.8;break;
		case 7:sum+=a[7]*43;break;
		case 8:sum+=a[8]*56;break;
		case 9:sum+=a[9]*65;break;
	   } 
    }    
	printf("%.1f",sum);
	return 0;
与上题一样，先定义一个数组，然后再把数据输进去，不同的数据要乘以不同的单价，选用switch语句将各种书总价算出并加和，得总费用



校门外的树
总时间限制: 1000ms 内存限制: 65536kB
描述
某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。
由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
输入
第一行有两个整数L（1 <= L <= 10000）和 M（1 <= M <= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
对于20%的数据，区域之间没有重合的部分；
对于其它的数据，区域之间有重合的情况。
输出
包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。
样例输入
500 3
150 300
100 200
470 471
样例输出
298
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int l,m,n,a[10000],sum=0,i,x,y;
	scanf("%d%d",&l,&m);
	for(i=0;i<=l;i++)
	a[i]=1;
	n=l+1;
	for(i=1;i<=m;i++){
	  scanf("%d%d",&x,&y);
      for(int s=x;s<=y;s++)
      if(a[s]){
    	a[s]=0;
    	n--;}
	}
	printf("%d",n);
	return 0;
}
这道题要用到标记法，将数轴上的所有树都标记为1，在区域中间的树由1标记为0，同时将总数减1。所有区域标完后，即可得最后的剩余的树的数目。



数组逆序重放
总时间限制: 1000ms 内存限制: 65536kB
描述
将一个数组中的值按逆序重新存放。例如，原来的顺序为8,6,5,4,1。要求改为1,4,5,6,8。
输入
输入为两行：第一行数组中元素的个数n（1<n<100)，第二行是n个整数，每两个整数之间用空格分隔。
输出
输出为一行：输出逆序后数组的整数，每两个整数之间用空格分隔。
样例输入
5
8 6 5 4 1
样例输出
1 4 5 6 8
ac代码：
#include<stdio.h>
int main()
{
	int i,a[100],n;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	for(i=n-1;i>=0;i--)
	printf("%d ",a[i]);
	return 0;
}
这个题其实可以讨巧，不需要将数组中的值按逆序重新存放，只需要逆序输出就可以了。



有趣的跳跃
总时间限制: 1000ms 内存限制: 65536kB
描述
一个长度为n（n>0）的序列中存在“有趣的跳跃”当前仅当相邻元素的差的绝对值经过排序后正好是从1到(n-1)。例如，1 4 2 3存在“有趣的跳跃”，因为差的绝对值分别为3,2,1。当然，任何只包含单个元素的序列一定存在“有趣的跳跃”。你需要写一个程序判定给定序列是否存在“有趣的跳跃”。
输入
一行，第一个数是n（0 < n < 3000），为序列长度，接下来有n个整数，依次为序列中各元素，各元素的绝对值均不超过1,000,000,000。
输出
一行，若该序列存在“有趣的跳跃”，输出"Jolly"，否则输出"Not jolly"。
样例输入
4 1 4 2 3
样例输出
Jolly
ac代码：
#include<stdio.h>
#include<math.h>
int main()
{
	int i,j,N,NA,NB,a[100],b[100],sa=0,sb=0;
	scanf("%d%d%d",&N,&NA,&NB);
	for(i=0;i<NA;i++)
	scanf("%d",&a[i]);
	for(i=0;i<NB;i++)
	scanf("%d",&b[i]);
	for(i=0,j=1;j<=N;j++){
		if(a[i]-b[i]==-2||a[i]-b[i]==-3||a[i]-b[i]==5)
			sa++;
		else if(a[i]-b[i]==2||a[i]-b[i]==3||a[i]-b[i]==-5)
			sb++;
	    else;
		i++;
		if(i>=NA)
		a[i]=a[i-NA];
		if(i>=NB)
		b[i]=b[i-NB];	
	}
	if(sa>sb)
	printf("A\n");
	else if(sa<sb)
	printf("B\n");
	else
	printf("draw\n");
	return 0;
}
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int i,a[3000],b[3000],n,j,t;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	for(i=0;i<n-1;i++)
        b[i]=fabs(a[i]-a[i+1]);
        sort(b,b+n-1);
        for(j=0;j<n-1;j++)
	{
    	if(b[j]==j+1)
    	continue;
    	else
    	break;
	}
	if(j>=n-1)	 
	printf("Jolly\n");
	else
	printf("Not jolly\n");
	return 0;
}
解题思路：这道题的重点在于要判断相邻元素的差的绝对值经过排序后正好是从1到(n-1)，所以我另外定义了一个数组b用于存放相邻元素的差的绝对值，然后再排序，最后再判断数组b中的元素是否是从1到(n-1)。
其实还有另外一种做法，数组b可以用来计数（先将数组b中的元素全部赋值零）。先输入n和数组中的第一个元素，然后再利用循环输入数组中其余元素，在输入的同时将该元素与前一个元素做差并求绝对值，
然后将该绝对值赋予给另一个变量j，b[j]++。最后判断数组b中b[1]到b[n-1]是否全为1，若是，则输出Jolly，若否，则输出Not jolly。
可见第二种算法的循环更少，没有排序，复杂度更低，更加优化，因而推荐第二种算法。



石头剪刀布
总时间限制: 1000ms 内存限制: 65536kB
描述
石头剪刀布是常见的猜拳游戏。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。
一天，小A和小B正好在玩石头剪刀布。已知他们的出拳都是有周期性规律的，比如：“石头-布-石头-剪刀-石头-布-石头-剪刀……”，就是以“石头-布-石头-剪刀”为周期不断循环的。请问，小A和小B比了N轮之后，谁赢的轮数多？
输入
输入包含三行。
第一行包含三个整数：N，NA，NB，分别表示比了N轮，小A出拳的周期长度，小B出拳的周期长度。0 < N,NA,NB < 100。
第二行包含NA个整数，表示小A出拳的规律。
第三行包含NB个整数，表示小B出拳的规律。
其中，0表示“石头”，2表示“剪刀”，5表示“布”。相邻两个整数之间用单个空格隔开。
输出
输出一行，如果小A赢的轮数多，输出A；如果小B赢的轮数多，输出B；如果两人打平，输出draw。
样例输入
10 3 4
0 2 5
0 5 0 2
样例输出
A
提示
对于测试数据，猜拳过程为：
A：0 2 5 0 2 5 0 2 5 0
B：0 5 0 2 0 5 0 2 0 5
A赢了4轮，B赢了2轮，双方打平4轮，所以A赢的轮数多。
ac代码:：
#include<stdio.h>
int main()
{
	int i,j,N,NA,NB,a[100],b[100],sa=0,sb=0;
	scanf("%d%d%d",&N,&NA,&NB);
	for(i=0;i<NA;i++)
	scanf("%d",&a[i]);
	for(i=0;i<NB;i++)
	scanf("%d",&b[i]);
	for(i=0,j=1;j<=N;j++){
		if(a[i]-b[i]==-2||a[i]-b[i]==-3||a[i]-b[i]==5)
			sa++;
		else if(a[i]-b[i]==2||a[i]-b[i]==3||a[i]-b[i]==-5)
			sb++;
	    else;
		i++;
		if(i>=NA)
		a[i]=a[i-NA];
		if(i>=NB)
		b[i]=b[i-NB];	
	}
	if(sa>sb)
	printf("A\n");
	else if(sa<sb)
	printf("B\n");
	else
	printf("draw\n");
	return 0;
}
解题思路：由于本题的循环次数较小（小于100），因此用循环将每次的猜拳遍历并且记录结果，最后比较谁赢的次数多。需要注意：这种做法仅限于循环次数较小的题，对于其他循环较大的题（大于10^6），需另寻他法。
若本题循环次数过大，则可以采取另一种算法：先计算出A和B出拳周期的最小公倍数并算出在最小公周期内A和B各自赢了多少。然后再将猜拳次数除以最小公周期得重复的次数，并算出余数。将重复的次数分别乘以AB在最小公周期内各自赢的次数。最后循环
余数次，算出AB各自赢的总局数，再比较大小谁赢的次数多。



小鱼比可爱
题目描述
人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。
输入格式
第一行输入一个整数 nn，表示鱼的数目。
第二行内输入 nn 个整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度。
输出格式
行内输出 nn 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。
输入输出样例
输入
6
4 3 0 5 1 2
输出
0 0 0 3 1 2
说明/提示
对于 100\%100% 的数据，n\leq 100n≤100。
ac代码:
#include<iostream>
using namespace std;
int a[101],b[101],n;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)//读入每条鱼的可爱值
        cin>>a[i];
    for (int i=1;i<=n;i++)//枚举N条鱼
        for (int j=i;j>=1;j--)//从第I个位置倒着往前找
        {
            if (a[j]<a[i])
            b[i]++;//如果找到比第I条鱼丑的，统计数组b对应的b[i]+1
        }
    for (int i=1;i<=n;i++) cout<<b[i]<<" ";//输出
    return 0;
}
